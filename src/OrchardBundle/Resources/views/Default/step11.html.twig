{% extends '::step-base.html.twig' %}

{% block body %}

<div class="row step-1">
  <div class="col-xs-12 col-sm-12 col-md-5 col-lg-5">
    <h1 class="display-3">Paso 1.1</h1>
    <form>
      <div class="form-group">
        <label class="label-control" for="Name" data-toggle="tooltip" data-placement="right" title="Campo requerido">¿Cómo se llama tu huerto?</label>
        <span style="display:none;color:red">Campo requerido</span>
        <input type="text" class="form-control required" id="Name" placeholder="Nombre de tu huerto">
      </div>
      <div class="form-group">
        <label for="form-address" data-toggle="tooltip" data-placement="right" title="Campo requerido">¿Dónde está tu huerto?<small id="fileHelp" class="form-text text-muted">
          <span class="label-control" style="display:none;color:red">Campo requerido</span>
          <input type="text" class="form-control required" id="autocomplete" placeholder="Dirección de tu huerto">
          <i>Mueve el marcador para seleccionar la entrada a tu huerto.</i></small></label>

          <input type="text" id="Town" hidden="hidden">
          <input type="text" id="Street" hidden="hidden">
          <input type="text" id="Number" hidden="hidden">
          <input type="text" id="Zipcode" hidden="hidden">
          <input type="text" id="Geometry" hidden="hidden">
          <input type="text" id="Step" hidden="hidden" value="11">

        </div>
      </form>

      <div class="fixed-buttons">
        <button type="button" class="btn btn-secondary col-xs-6 col-sm-6 col-md-6 col-lg-6 ">Atrás</button>
        <button id="btn-siguiente" type="submit" class="btn btn-primary col-xs-6 col-sm-6 col-md-6 col-lg-6" disabled="disabled">Siguiente</button>
      </div>
    </div>

    <div class="map col-xs-12 col-sm-12 col-md-7 col-lg-7">
      <div id="map" class="map"></div>
    </div>

    <div id="myModal" class="modal fade bd-example-modal-lg" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg">
        <div class="alert alert-danger" role="alert">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
          <strong>Cuidado!</strong> Parece que no has rellenado algún dato de tu huerto.
        </div>
      </div>
    </div>
  </div>

</div>

{% endblock %}

{% block javascripts %}

<script type="text/javascript">

// This example displays an address form, using the autocomplete feature
// of the Google Places API to help users fill in the information.

var placeSearch, autocomplete;
var componentForm = {
  street_number: 'short_name',
  route: 'long_name',
  locality: 'long_name',
  administrative_area_level_1: 'short_name',
  country: 'long_name',
  postal_code: 'short_name'
};

function initAutocomplete() {
  // Create the autocomplete object, restricting the search to geographical
  // location types.
  autocomplete = new google.maps.places.Autocomplete(
    /** @type {!HTMLInputElement} */(document.getElementById('autocomplete')));

  // When the user selects an address from the dropdown, populate the address
  // fields in the form.
  autocomplete.addListener('place_changed', fillInAddress);
}

function fillInAddress() {
  // Get the place details from the autocomplete object.
  var place = autocomplete.getPlace();

  var marker = L.marker([place.geometry.location.lat(), place.geometry.location.lng()], {draggable: true});

  prepareMarker(marker);

  /*// Get each component of the address from the place details
  // and fill the corresponding field on the form.
  for (var i = 0; i < place.address_components.length; i++) {
    var addressType = place.address_components[i].types[0];
    if (componentForm[addressType]) {
      var val = place.address_components[i][componentForm[addressType]];
      document.getElementById(addressType).value = val;
    }
  }*/
}

/*// Bias the autocomplete object to the user's geographical location,
// as supplied by the browser's 'navigator.geolocation' object.
function geolocate() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(function(position) {
      var geolocation = {
        lat: position.coords.latitude,
        lng: position.coords.longitude
      };
      var circle = new google.maps.Circle({
        center: geolocation,
        radius: position.coords.accuracy
      });
      autocomplete.setBounds(circle.getBounds());
    });
  }
}*/

$(function() {
  initMap();
});

$("form input").change(function(){
  console.log('Validando');
  validateForm();
});

$("form input").keyup(function(){
  console.log('Validando');
  validateForm();
});

function validateForm() {
  var empty = false;
  $('form input').each(function() {
    if ($(this).val().length == 0) {
      empty = true;
    }
  });

  if (empty) {
    $('#btn-siguiente').attr('disabled', 'disabled');
  } else {
    $('#btn-siguiente').removeAttr('disabled');
  }
}

$('#btn-siguiente').on('click', function() {
  var form =  {
    name: $('#orchard-name').val(),
    town: $('#orchard-town').val(),
    street: $('#orchard-street').val(),
    number: $('#orchard-number').val(),
    zipcode: $('#orchard-zipcode').val(),
    geometry: $('#orchard-geometry').val()
  };

  $.ajax({
    type: 'POST',
    dataType: 'json',
    url: '/orchard/insert/{step}',
    data: form,
    success: function(data) {
      if (data.redirect) {
          window.location.href = data.redirect;
      }
    }
  });

});

var map;

// Initialise the FeatureGroup to store editable layers
var editableItems = new L.FeatureGroup();

var nonEditableItems = new L.FeatureGroup();

var nonEditableItemsBackup = new L.FeatureGroup();

function initMap() {
  //Inicializamos el mapa y sus controles (es necesário tener un div de id="map") y lo centramos en Valencia por defecto
  //Pedimos la geolocalización al usuario, si la acepta centramos el mapa en su ubicación, sinó mostramos el error por consola
  map = L.map('map', {
    zoomControl: false
  });

  L.control.zoom({
    position: 'topright',
    zoomInTitle: 'Acercar',
    zoomOutTitle: 'Alejar'
  }).addTo(map);

  L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

  map.setView([39.4077013, -0.5015955], 12);

  navigator.geolocation.getCurrentPosition(success, error, options);

  var options = {
    enableHighAccuracy: true,
    timeout: 5000,
    maximumAge: 0
  };

  function success(pos) {
    var crd = pos.coords;

    console.log('Your current position is:');
    console.log('Latitude : ' + crd.latitude);
    console.log('Longitude: ' + crd.longitude);
    console.log('More or less ' + crd.accuracy + ' meters.');

    setMap(crd);
  };

  function error(err) {
    console.warn('ERROR(' + err.code + '): ' + err.message);
    setMap();
  };
}

function initDraw() {
  //Inicializamos el plugin Draw y añadimos la capa de layers que se van a poder editar (sólo polígonos)
  L.drawLocal = {
    draw: {
      toolbar: {
              // #TODO: this should be reorganized where actions are nested in actions
              // ex: actions.undo  or actions.cancel
              actions: {
                title: 'Cancelar dibujo',
                text: 'Cancelar'
              },
              finish: {
                title: 'Terminar el dibujo',
                text: 'Terminar'
              },
              undo: {
                title: 'Eliminar el último punto dibujado',
                text: 'Eliminar el último punto'
              },
              buttons: {
                polyline: 'Dibuja una polilínea',
                polygon: 'Dibuja un polígono!',
                rectangle: 'Dibuja un rectángulo!',
                circle: 'Dibuja un círculo!',
                marker: 'Dibuja un marcador!'
              }
            },
            handlers: {
              circle: {
                tooltip: {
                  start: 'Click and drag to draw circle.'
                },
                radius: 'Radius'
              },
              marker: {
                tooltip: {
                  start: 'Click map to place marker.'
                }
              },
              polygon: {
                tooltip: {
                  start: 'Haz clic para empezar a dibujar la forma.',
                  cont: 'Haz clic para continuar dibujando la forma.',
                  end: 'Haz clic en primer punto para cerrar esta forma.'
                }
              },
              polyline: {
                error: '<strong>Error:</strong> shape edges cannot cross!',
                tooltip: {
                  start: 'Click to start drawing line.',
                  cont: 'Click to continue drawing line.',
                  end: 'Click last point to finish line.'
                }
              },
              rectangle: {
                tooltip: {
                  start: 'Click and drag to draw rectangle.'
                }
              },
              simpleshape: {
                tooltip: {
                  end: 'Release mouse to finish drawing.'
                }
              }
            }
          },
          edit: {
            toolbar: {
              actions: {
                save: {
                  title: 'Guardar cambios.',
                  text: 'Guardar'
                },
                cancel: {
                  title: 'Cancelar la edición, descarta todos los cambios.',
                  text: 'Cancelar'
                }
              },
              buttons: {
                edit: 'Editar capas.',
                editDisabled: 'No hay capas que editar.',
                remove: 'Eliminar capas.',
                removeDisabled: 'No hay capas que eliminar.'
              }
            },
            handlers: {
              edit: {
                tooltip: {
                  text: 'Arrastre los puntos o marcadores para editar la forma.',
                  subtext: 'Haga clic en cancelar para deshacer los cambios.'
                }
              },
              remove: {
                tooltip: {
                  text: 'Haga clic en una forma para eliminar'
                }
              }
            }
          }
        };

        // Initialise the draw control and pass it the FeatureGroup of editable layers
        var drawControl = new L.Control.Draw({
          draw: {
            marker: false,
            circle: false,
            polyline: false,
            rectangle: false,
            polygon: {
              allowIntersection: false,
              showArea: true
            }
          },
          edit: {
            featureGroup: editableItems,
            remove: false
          }
        });
        map.addControl(drawControl);
      }

      function initGeocoder() {
  //Inicializamos el plugin Geocoder y devolvemos la variable para poder utilizarla más tarde
  var options = {
    markers: {draggable :true},
    layers: 'address',
    'boundary.country': 'ES',
    sources: 'oa',
    position: 'topright',
    fullWidth: false,
    placeholder: 'Busca tu dirección'
  };

  var geocoder = L.control.geocoder('mapzen-9gW9cQ', options).addTo(map);

  return geocoder;
}

function setMap(crd){
  //Si el usuario ha permitido la geolocalización centramos el mapa en su ubicación
  if(crd != undefined) {
    map.setView([crd.latitude, crd.longitude], 12);
  }

  map.addLayer(editableItems);

  map.addLayer(nonEditableItems);

  initDraw();

  var deleting = false;

  map.on('draw:drawstart', function (e) {
    var type = e.layerType,
    layer = e.layer;

    //Cuando empezemos a dibujar debemos borrar todas las capas para evitar conflictos

    clearEditableLayer(true);

    clearNonEditableLayer(true);

    $('#orchard-geometry').attr('value', "");
  });

  map.on('draw:created', function (e) {
    var type = e.layerType,
    layer = e.layer;

    layer.on('click', function(e) {
      if(deleting) {
        console.log('Borrando capa no editable');
        clearNonEditableLayer(true);
      }
    });

    // Do whatever else you need to. (save to db, add to map etc)
    map.addLayer(layer);

    editableItems.addLayer(layer);

    var marker = L.marker([layer.getBounds().getCenter().lat, layer.getBounds().getCenter().lng], {draggable: true});

    prepareMarker(marker);
  });

  map.on('draw:edited', function (e) {
    var layers = e.layers;
    layers.eachLayer(function (layer) {
      prepareGeometry(undefined, layer);
    });
  });

  /*map.on('draw:deletestart', function (e) {
    deleting = true;
    console.log(nonEditableItems.getLayers());
    nonEditableItemsBackup.addLayer((nonEditableItems.getLayers()[0]));
    nonEditableItemsBackup.addLayer((nonEditableItems.getLayers()[nonEditableItems.getLayers().length - 1]));

    $("a[title='Guardar cambios.']").on('click', function(e) {
      console.log('Has clickado guardar');
    });

    $("a[title='Cancelar la edición, descarta todos los cambios.']").on('click', function(e) {
      console.log('Has terminado de borrar');
      deleting = false;
      map.addLayer(nonEditableItemsBackup);
      nonEditableItemsBackup.eachLayer(function(layer) {
          map.addLayer(layer);
      });
    });
  });

  var geocoder = initGeocoder();

  /*geocoder.on('select', function (e) {

    $('.leaflet-pelias-control').removeClass('leaflet-pelias-expanded');

    clearEditableLayer(true);

    clearNonEditableLayer(true);

    $('#orchard-geometry').attr('value', "");

    var marker = geocoder.markers[0];

    prepareMarker(marker);
  });

  geocoder.on('reset', function (e) {
    clearNonEditableLayer(false);
  });*/
}

function reverseGeocoding(marker) {
  $.getJSON('https://search.mapzen.com/v1/reverse?api_key=mapzen-9gW9cQ&point.lat='+marker.getLatLng().lat+'&point.lon='+marker.getLatLng().lng+'&size=1&layers=address&boundary.country=ES', function(data, status, xhr) {
    if(data.features[0] == undefined){
      marker.bindPopup('No se han encontrado resultados.').openPopup();
    }else{
      marker.bindPopup(data.features[0].properties.label).openPopup();
      if(data.features[0].properties.locality != null){
        var circle = L.circle([marker.getLatLng().lat, marker.getLatLng().lng], data.features[0].properties.distance*1000).addTo(map);
        nonEditableItems.addLayer(circle);
        $('#Town').attr('value', data.features[0].properties.locality).trigger('change');
        $('#Street').attr('value', data.features[0].properties.street).trigger('change');
        $('#Number').attr('value', data.features[0].properties.housenumber).trigger('change');
        $('#Zipcode').attr('value', data.features[0].properties.postalcode).trigger('change');
        console.log('Número '+data.features[0].properties.housenumber+', Calle '+data.features[0].properties.street+', Localidad '+data.features[0].properties.locality+', CP '+data.features[0].properties.postalcode+', Pais '+data.features[0].properties.country+', Distancia '+data.features[0].properties.distance*1000+' m, Exacto a '+data.features[0].properties.confidence);
      }else{
        var circle = L.circle([marker.getLatLng().lat, marker.getLatLng().lng], data.features[0].properties.distance*1000).addTo(map);
        nonEditableItems.addLayer(circle);
        $('#Town').attr('value', data.features[0].properties.localadmin).trigger('change');
        $('#Street').attr('value', data.features[0].properties.street).trigger('change');
        $('#Number').attr('value', data.features[0].properties.housenumber).trigger('change');
        $('#Zipcode').attr('value', data.features[0].properties.postalcode).trigger('change');
        console.log('Número '+data.features[0].properties.housenumber+', Calle '+data.features[0].properties.street+', Localidad '+data.features[0].properties.localadmin+', Pais '+data.features[0].properties.country+', Distancia '+data.features[0].properties.distance*1000+' m, Exacto a '+data.features[0].properties.confidence);
      }
    }
  });

  if(map.hasLayer(editableItems.getLayers()[editableItems.getLayers().length - 1])) {
    prepareGeometry(marker, editableItems.getLayers()[editableItems.getLayers().length - 1]);
  }else{
    prepareGeometry(marker);
  }
}

function storeGeometry(layer) {
    //Layer puede ser tanto un polígono como un marcador
    //Convertimos el layer a un objetivo GeoJSON y lo convertimos a string para poder guardarlo
    var geojson = layer.toGeoJSON();
    var forma = JSON.stringify(geojson);

    return forma;
  }

  function retrieveGeometry(geometry) {
    //Geometry será el string recuperado de la BBDD
    //Convertimos el string en un objeto JSON eliminando los errores y lo añadimos al mapa
    var geojsonFeature = JSON.parse(geometry.replace(/&quot;/g,'"'));

    L.geoJSON(geojsonFeature).addTo(map);
  }

  function prepareMarker(marker) {
    marker.on('dragend', function() { reverseGeocoding(marker); });

    marker.on('dragstart', function() {
      clearNonEditableLayer(false);
    });

    marker.addTo(map);

    nonEditableItems.addLayer(marker);

    reverseGeocoding(marker);
  }

  function prepareGeometry(marker, polygon) {
    var geojsonFeature;
    if(marker != undefined) {
      geojsonFeature = {
        "type": "Feature",
        "properties": {},
        "geometry": {
          "type": "Point",
          "coordinates": [marker.getLatLng().lng, marker.getLatLng().lat]
        }
      };
    }

    if(polygon != undefined) {
      var geojson = polygon.toGeoJSON()
      var forma = JSON.stringify(geojson);

      if(marker == undefined) {
        $('#Geometry').attr('value', $('#Geometry').val().slice(0, 121)+forma+']');
      }else{
        $('#Geometry').attr('value', '['+JSON.stringify(geojsonFeature)+', '+forma+']');
      }
    }else{
      $('#Geometry').attr('value', JSON.stringify(geojsonFeature));
    }
  }

  function clearEditableLayer(all) {
    editableItems.eachLayer(function(layer) {
      if(all) {
        map.removeLayer(layer);
      }else{
        if(layer instanceof L.Circle) {
          map.removeLayer(layer);
        }
      }
    });
  }

  function clearNonEditableLayer(all) {
    nonEditableItems.eachLayer(function(layer) {
      if(all) {
        map.removeLayer(layer);
      }else{
        if(layer instanceof L.Circle) {
          map.removeLayer(layer);
        }
      }
    });
  }

</script>

<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCoEnPxI5c67EcNsgznNOqhUn7Vz2RL2Xg&signed_in=true&libraries=places&callback=initAutocomplete"
async defer></script>

{% endblock %}
